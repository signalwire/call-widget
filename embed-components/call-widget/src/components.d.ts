/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { IncomingCallNotification, SignalWireClientParams } from "@signalwire/js";
import { TranscriptEntry } from "./components/call-transcript-viewer/call-transcript-viewer";
export { IncomingCallNotification, SignalWireClientParams } from "@signalwire/js";
export { TranscriptEntry } from "./components/call-transcript-viewer/call-transcript-viewer";
export namespace Components {
    interface CallAudio {
    }
    interface CallContext {
        "audio": boolean;
        "audioCodecs"?: string;
        "debugLogWsTraffic"?: boolean;
        "destination": string;
        "dial": () => Promise<any>;
        "host"?: string;
        "logLevel"?: SignalWireClientParams['logLevel'];
        "token": string;
        "userVariables": string;
        "video": boolean;
    }
    interface CallControls {
    }
    interface CallIcon {
    }
    interface CallIncoming {
        "showModal": boolean;
    }
    interface CallInformationDialog {
        "message": string;
        "title": string;
    }
    interface CallModal {
        "open": boolean;
        "setOpen": (value: boolean) => Promise<void>;
        "trigger"?: string;
    }
    interface CallTranscriptViewer {
        "transcriptHistory": TranscriptEntry[];
    }
    interface CallVideo {
    }
}
export interface CallContextCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLCallContextElement;
}
export interface CallControlsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLCallControlsElement;
}
export interface CallInformationDialogCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLCallInformationDialogElement;
}
export interface CallVideoCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLCallVideoElement;
}
declare global {
    interface HTMLCallAudioElement extends Components.CallAudio, HTMLStencilElement {
    }
    var HTMLCallAudioElement: {
        prototype: HTMLCallAudioElement;
        new (): HTMLCallAudioElement;
    };
    interface HTMLCallContextElementEventMap {
        "clientReady": any;
        "clientIncomingCall": IncomingCallNotification;
        "callStarted": void;
        "callEnded": void;
    }
    interface HTMLCallContextElement extends Components.CallContext, HTMLStencilElement {
        addEventListener<K extends keyof HTMLCallContextElementEventMap>(type: K, listener: (this: HTMLCallContextElement, ev: CallContextCustomEvent<HTMLCallContextElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLCallContextElementEventMap>(type: K, listener: (this: HTMLCallContextElement, ev: CallContextCustomEvent<HTMLCallContextElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLCallContextElement: {
        prototype: HTMLCallContextElement;
        new (): HTMLCallContextElement;
    };
    interface HTMLCallControlsElementEventMap {
        "hangup": void;
    }
    interface HTMLCallControlsElement extends Components.CallControls, HTMLStencilElement {
        addEventListener<K extends keyof HTMLCallControlsElementEventMap>(type: K, listener: (this: HTMLCallControlsElement, ev: CallControlsCustomEvent<HTMLCallControlsElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLCallControlsElementEventMap>(type: K, listener: (this: HTMLCallControlsElement, ev: CallControlsCustomEvent<HTMLCallControlsElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLCallControlsElement: {
        prototype: HTMLCallControlsElement;
        new (): HTMLCallControlsElement;
    };
    interface HTMLCallIconElement extends Components.CallIcon, HTMLStencilElement {
    }
    var HTMLCallIconElement: {
        prototype: HTMLCallIconElement;
        new (): HTMLCallIconElement;
    };
    interface HTMLCallIncomingElement extends Components.CallIncoming, HTMLStencilElement {
    }
    var HTMLCallIncomingElement: {
        prototype: HTMLCallIncomingElement;
        new (): HTMLCallIncomingElement;
    };
    interface HTMLCallInformationDialogElementEventMap {
        "dialogClosed": void;
    }
    interface HTMLCallInformationDialogElement extends Components.CallInformationDialog, HTMLStencilElement {
        addEventListener<K extends keyof HTMLCallInformationDialogElementEventMap>(type: K, listener: (this: HTMLCallInformationDialogElement, ev: CallInformationDialogCustomEvent<HTMLCallInformationDialogElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLCallInformationDialogElementEventMap>(type: K, listener: (this: HTMLCallInformationDialogElement, ev: CallInformationDialogCustomEvent<HTMLCallInformationDialogElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLCallInformationDialogElement: {
        prototype: HTMLCallInformationDialogElement;
        new (): HTMLCallInformationDialogElement;
    };
    interface HTMLCallModalElement extends Components.CallModal, HTMLStencilElement {
    }
    var HTMLCallModalElement: {
        prototype: HTMLCallModalElement;
        new (): HTMLCallModalElement;
    };
    interface HTMLCallTranscriptViewerElement extends Components.CallTranscriptViewer, HTMLStencilElement {
    }
    var HTMLCallTranscriptViewerElement: {
        prototype: HTMLCallTranscriptViewerElement;
        new (): HTMLCallTranscriptViewerElement;
    };
    interface HTMLCallVideoElementEventMap {
        "hangup": void;
    }
    interface HTMLCallVideoElement extends Components.CallVideo, HTMLStencilElement {
        addEventListener<K extends keyof HTMLCallVideoElementEventMap>(type: K, listener: (this: HTMLCallVideoElement, ev: CallVideoCustomEvent<HTMLCallVideoElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLCallVideoElementEventMap>(type: K, listener: (this: HTMLCallVideoElement, ev: CallVideoCustomEvent<HTMLCallVideoElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLCallVideoElement: {
        prototype: HTMLCallVideoElement;
        new (): HTMLCallVideoElement;
    };
    interface HTMLElementTagNameMap {
        "call-audio": HTMLCallAudioElement;
        "call-context": HTMLCallContextElement;
        "call-controls": HTMLCallControlsElement;
        "call-icon": HTMLCallIconElement;
        "call-incoming": HTMLCallIncomingElement;
        "call-information-dialog": HTMLCallInformationDialogElement;
        "call-modal": HTMLCallModalElement;
        "call-transcript-viewer": HTMLCallTranscriptViewerElement;
        "call-video": HTMLCallVideoElement;
    }
}
declare namespace LocalJSX {
    interface CallAudio {
    }
    interface CallContext {
        "audio"?: boolean;
        "audioCodecs"?: string;
        "debugLogWsTraffic"?: boolean;
        "destination": string;
        "host"?: string;
        "logLevel"?: SignalWireClientParams['logLevel'];
        "onCallEnded"?: (event: CallContextCustomEvent<void>) => void;
        "onCallStarted"?: (event: CallContextCustomEvent<void>) => void;
        "onClientIncomingCall"?: (event: CallContextCustomEvent<IncomingCallNotification>) => void;
        "onClientReady"?: (event: CallContextCustomEvent<any>) => void;
        "token": string;
        "userVariables"?: string;
        "video"?: boolean;
    }
    interface CallControls {
        "onHangup"?: (event: CallControlsCustomEvent<void>) => void;
    }
    interface CallIcon {
    }
    interface CallIncoming {
        "showModal"?: boolean;
    }
    interface CallInformationDialog {
        "message": string;
        "onDialogClosed"?: (event: CallInformationDialogCustomEvent<void>) => void;
        "title": string;
    }
    interface CallModal {
        "open"?: boolean;
        "trigger"?: string;
    }
    interface CallTranscriptViewer {
        "transcriptHistory"?: TranscriptEntry[];
    }
    interface CallVideo {
        "onHangup"?: (event: CallVideoCustomEvent<void>) => void;
    }
    interface IntrinsicElements {
        "call-audio": CallAudio;
        "call-context": CallContext;
        "call-controls": CallControls;
        "call-icon": CallIcon;
        "call-incoming": CallIncoming;
        "call-information-dialog": CallInformationDialog;
        "call-modal": CallModal;
        "call-transcript-viewer": CallTranscriptViewer;
        "call-video": CallVideo;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "call-audio": LocalJSX.CallAudio & JSXBase.HTMLAttributes<HTMLCallAudioElement>;
            "call-context": LocalJSX.CallContext & JSXBase.HTMLAttributes<HTMLCallContextElement>;
            "call-controls": LocalJSX.CallControls & JSXBase.HTMLAttributes<HTMLCallControlsElement>;
            "call-icon": LocalJSX.CallIcon & JSXBase.HTMLAttributes<HTMLCallIconElement>;
            "call-incoming": LocalJSX.CallIncoming & JSXBase.HTMLAttributes<HTMLCallIncomingElement>;
            "call-information-dialog": LocalJSX.CallInformationDialog & JSXBase.HTMLAttributes<HTMLCallInformationDialogElement>;
            "call-modal": LocalJSX.CallModal & JSXBase.HTMLAttributes<HTMLCallModalElement>;
            "call-transcript-viewer": LocalJSX.CallTranscriptViewer & JSXBase.HTMLAttributes<HTMLCallTranscriptViewerElement>;
            "call-video": LocalJSX.CallVideo & JSXBase.HTMLAttributes<HTMLCallVideoElement>;
        }
    }
}
